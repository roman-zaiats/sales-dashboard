scalar DateTime
scalar JSON

type Query {
  salesList(filter: SaleFilterInput, sort: SaleSortInput, pagination: PaginationInput = { skip: 0, limit: 50 }): SaleListPayload!
  saleById(id: ID!): Sale
  delayedSales(filter: SaleFilterInput, sort: SaleSortInput, pagination: PaginationInput = { skip: 0, limit: 50 }): SaleListPayload!
  listUsersForAssignment: [User!]!
}

type Mutation {
  updateSaleStatus(id: ID!, status: SaleStatus!, expected_updated_at: DateTime): Sale!
  updateSaleDelay(id: ID!, delivery_delay_at: DateTime, expected_updated_at: DateTime): Sale!
  updateSaleProblem(id: ID!, problem_reason: String, expected_updated_at: DateTime): Sale!
  setSaleFilledBy(id: ID!, user_id: ID!): Sale!
  addSaleTag(id: ID!, tag_name: String!): Sale!
  removeSaleTag(id: ID!, tag_name: String!): Sale!
  addSaleComment(id: ID!, comment: String!): SaleComment!
}

type SaleListPayload {
  items: [Sale!]!
  totalCount: Int!
}

enum SaleStatus {
  RECEIVED
  COMPLETED
  DELAYED
  PROBLEM
}

type User {
  id: ID!
  authSub: String
  firstName: String
  lastName: String
  fullName: String!
}

type Sale {
  id: ID!
  externalSaleId: String!
  listing: Listing
  buyerEmail: String
  sourcePayload: JSON
  status: SaleStatus!
  deliveryDelayAt: DateTime
  problemReason: String
  filledBy: User
  dashboardTags: [DashboardTag!]!
  comments: [SaleComment!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type DashboardTag {
  id: ID!
  name: String!
}

type ListingFee {
  type: String
  description: String
  amount: Float
}

type Listing {
  id: ID!
  sourceListingId: String!
  listingId: String
  adviceIndex: Int
  area: String
  assignedPos: String
  creationDate: DateTime
  creationType: String
  eventId: String
  eventName: String
  exchange: String
  exchangesForSale: [String!]!
  extraFee: Float
  faceValue: Float
  lastPosModificationDate: DateTime
  lowerPrice: Float
  offerId: String
  originalSection: String
  placesIds: [String!]!
  price: Float
  priceMultiplier: Float
  pricingRuleMultiplierChangeTime: DateTime
  quality: Float
  quantity: Int
  row: String
  rulePriceMultiplierIndex: Int
  section: String
  splitRule: String
  startRow: String
  status: String
  statusChangeDate: DateTime
  subPlatform: String
  tags: [String!]!
  ticketTypeName: String
  venueName: String
  fees: [ListingFee!]
  sourcePayload: JSON
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SaleComment {
  id: ID!
  author: String!
  comment: String!
  createdAt: DateTime!
}

input PaginationInput {
  skip: Int = 0
  limit: Int = 50
}

input SaleFilterInput {
  status: SaleStatus
  tagIds: [ID!]
  has_delay: Boolean
  overdue_only: Boolean
  search: String
}

input SaleSortInput {
  field: SaleSortField!
  direction: SortDirection!
}

enum SaleSortField {
  created_at
  updated_at
  delivery_delay_at
  status
}

enum SortDirection {
  ASC
  DESC
}
